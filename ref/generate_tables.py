#!/usr/bin/env python3
"""
generate_tables.py — Generate precomputed ROM tables for RTAFE.

Outputs:
    src/math/tables.h  — extern declarations
    src/math/tables.c  — const arrays (window LUTs + FFT twiddle factors)

Usage:
    python ref/generate_tables.py            # default N=256
    python ref/generate_tables.py --N 512    # custom frame length
"""

import argparse
import numpy as np
from pathlib import Path
from datetime import datetime

# ── Window functions ─────────────────────────────────────────────────────────

def hann_window(N: int) -> np.ndarray:
    """Hann (raised cosine): w[n] = 0.5 * (1 - cos(2*pi*n / (N-1)))"""
    n = np.arange(N)
    return 0.5 * (1.0 - np.cos(2.0 * np.pi * n / (N - 1)))


def hamming_window(N: int) -> np.ndarray:
    """Hamming: w[n] = 0.54 - 0.46 * cos(2*pi*n / (N-1))"""
    n = np.arange(N)
    return 0.54 - 0.46 * np.cos(2.0 * np.pi * n / (N - 1))


def blackman_window(N: int) -> np.ndarray:
    """Blackman: w[n] = 0.42 - 0.5*cos(2*pi*n/(N-1)) + 0.08*cos(4*pi*n/(N-1))"""
    n = np.arange(N)
    return (0.42
            - 0.50 * np.cos(2.0 * np.pi * n / (N - 1))
            + 0.08 * np.cos(4.0 * np.pi * n / (N - 1)))


def sine_window(N: int) -> np.ndarray:
    """Sine window: w[n] = sin(pi*n / (N-1))"""
    n = np.arange(N)
    return np.sin(np.pi * n / (N - 1))


WINDOWS = {
    "hann":     hann_window,
    "hamming":  hamming_window,
    "blackman": blackman_window,
    "sine":     sine_window,
}

# ── Q-format conversion ─────────────────────────────────────────────────────

def float_to_q15(arr: np.ndarray) -> np.ndarray:
    """Convert float array in [-1.0, +1.0) to Q1.15 (int16)."""
    return np.clip(np.round(arr * 32767), -32768, 32767).astype(np.int16)


def float_to_q31(arr: np.ndarray) -> np.ndarray:
    """Convert float array in [-1.0, +1.0) to Q1.31 (int32)."""
    return np.clip(np.round(arr * 2147483647), -2147483648, 2147483647).astype(np.int32)

# ── FFT twiddle factors ─────────────────────────────────────────────────────

def generate_twiddles(N: int):
    """
    Generate N/2 twiddle factors for radix-2 DIT FFT.
    W_N^k = cos(2*pi*k/N) - j*sin(2*pi*k/N),  k = 0..N/2-1

    Returns (cos_q31, sin_q31) each of length N/2.
    """
    k = np.arange(N // 2)
    angle = 2.0 * np.pi * k / N
    cos_vals = np.cos(angle)
    sin_vals = np.sin(angle)
    return float_to_q31(cos_vals), float_to_q31(sin_vals)

# ── C code emitters ──────────────────────────────────────────────────────────

def format_c_array(name: str, dtype: str, values: np.ndarray, cols: int = 8) -> str:
    """Format a numpy array as a C const array definition."""
    N = len(values)
    lines = [f"const {dtype} {name}[{N}] = {{"]
    for i in range(0, N, cols):
        chunk = values[i:i + cols]
        vals = ", ".join(f"{int(v):7d}" for v in chunk)
        comma = "," if (i + cols) < N else ""
        lines.append(f"    {vals}{comma}")
    lines.append("};")
    return "\n".join(lines)


def emit_tables_c(N: int, out_dir: Path) -> None:
    """Generate tables.c with all window LUTs and twiddle factors."""
    header = (
        f"/**\n"
        f" * @file tables.c\n"
        f" * @brief Auto-generated ROM tables — DO NOT EDIT BY HAND.\n"
        f" *\n"
        f" * Generated by ref/generate_tables.py on {datetime.now().strftime('%Y-%m-%d %H:%M')}\n"
        f" * Frame length N = {N}\n"
        f" */\n\n"
        f"#include \"tables.h\"\n"
    )

    sections = [header]

    # ── Window tables (Q1.15) ────────────────────────────────────────────
    sections.append("\n/* ── Window function tables (Q1.15) ──────────────────── */\n")

    for name, func in WINDOWS.items():
        w_float = func(N)
        w_q15 = float_to_q15(w_float)
        c_name = f"window_{name}_{N}"
        sections.append(format_c_array(c_name, "q15_t", w_q15))
        sections.append("")

    # ── FFT twiddle factors (Q1.31) ──────────────────────────────────────
    sections.append("\n/* ── FFT twiddle factors (Q1.31), N/2 entries ─────── */\n")

    cos_q31, sin_q31 = generate_twiddles(N)
    sections.append(format_c_array(f"twiddle_cos_{N}", "q31_t", cos_q31))
    sections.append("")
    sections.append(format_c_array(f"twiddle_sin_{N}", "q31_t", sin_q31))
    sections.append("")

    out_file = out_dir / "tables.c"
    out_file.write_text("\n".join(sections))
    print(f"  wrote {out_file}  ({sum(len(s) for s in sections)} bytes)")


def emit_tables_h(N: int, out_dir: Path) -> None:
    """Generate tables.h with extern declarations for all tables."""
    lines = [
        f"/**",
        f" * @file tables.h",
        f" * @brief Extern declarations for precomputed ROM tables.",
        f" *",
        f" * Auto-generated by ref/generate_tables.py — DO NOT EDIT BY HAND.",
        f" * Frame length N = {N}",
        f" */",
        f"#pragma once",
        f"",
        f"#include \"rtafe/fe_types.h\"",
        f"",
        f"/* ── Window function tables (Q1.15) ──────────────────── */",
    ]

    for name in WINDOWS:
        c_name = f"window_{name}_{N}"
        lines.append(f"extern const q15_t {c_name}[{N}];")

    lines.append(f"")
    lines.append(f"/* ── FFT twiddle factors (Q1.31), N/2 entries ─────── */")
    lines.append(f"extern const q31_t twiddle_cos_{N}[{N // 2}];")
    lines.append(f"extern const q31_t twiddle_sin_{N}[{N // 2}];")
    lines.append(f"")

    out_file = out_dir / "tables.h"
    out_file.write_text("\n".join(lines) + "\n")
    print(f"  wrote {out_file}")

# ── Main ─────────────────────────────────────────────────────────────────────

def main():
    parser = argparse.ArgumentParser(description="Generate RTAFE ROM tables")
    parser.add_argument("--N", type=int, default=256, help="Frame length (default: 256)")
    args = parser.parse_args()
    N = args.N

    # Resolve output directory relative to this script's location
    script_dir = Path(__file__).resolve().parent          # ref/
    project_root = script_dir.parent                      # RTAFE/
    out_dir = project_root / "src" / "math"

    print(f"Generating tables for N={N} ...")
    emit_tables_h(N, out_dir)
    emit_tables_c(N, out_dir)
    print("Done.")


if __name__ == "__main__":
    main()
